tokenizing
==========

A	 letter
B	 letter or digit
D	 digit
W	 whitespace

numbers: optionally signed integers

identifiers: a letter, then any number of letters or digits


keywords: 	if		while	int		echo
			draw	wait	cmx		cmy
			mx		my		outputdraw


operators:			
				+		-			/		=		==		>		<		>=		<=		!=	
				+=		-=			/=		

				++
				--

									

parsing and codegen
===================

line = block = array of expression trees = expression tree with special shitroot


block := expr ';' | if (expr) block [else block] | while (expr) block | '{' { block ';' } '}' 

expr := ident asg-op expr | sum_expr
sum_expr := mul_expr { add-op mul_expr }+
mul_expr := unary_expr { mul-op unary_expr }+
unary_expr := [ - ] ( ident | integer )


block := expr ';' | if (expr) block [else block] | while (expr) block | '{' { expr ';' } '}' 
expr := ident asg-op expr | sum_expr {comp-op sum_expr} | 'int' ident [ = expr ] | instr expr
sum_expr := mul_expr { add-op mul_expr }+
mul_expr := unary_expr { mul-op unary_expr }+
unary_expr := ([ - ] ( ident | integer ) ) |  '(' expr ')' | ident ++ | ident -- | ++ ident | -- ident


{
	int x = 123 + 456;
	x++;
	echo x;
}




expression tree:

			 root node
		/		|			\
	child 1	  child 2  ...	child n

enum {		/* head_type */
	BLOCK,
	ADD,
	SUB,
	MULT,
	DIV,
	ASGN,
	IF,
	WHILE,
	NUMBER,
	VARIABLE
};

typedef struct exp_tree {
	char head_type;
	int head_dat;
	unsigned int child_count;
	struct exp_tree *child;
} exp_tree_t;


x = 1 + 2 * 3


		|
		|
		V

									3.	Do 0 10 2 246
		=
	/		\
   x		+						2.	Do 246 10 1 1
		  /	  \							Do 246 20 2 245
		  1    *
			  /  \			
			  2   3					1.	Do 245 10 1 2
										Do 245 40 1 3

(global)	int temp_register = 245;

int get_temp_storage() {
	if (temp_register > 255) {
		fail("expression stack overflow");
	}
	return temp_register++;
}

void new_temp_storage() {
	temp_register = 245;
}




if ( x > 3 ) {								IF			
	...block...							/	 |		\
}								( x > 3)   [block] < [line] >
< else
	...line... >



									Do 245 10 2 0		\	x > 3 => x - 3
									Do 245 30 1 3		/
									
									Do 246 1 [ size of "block" ]
									zbPtrTo 245 0 246
									
									[code for "block"]
									
						<			PtrTo 246
									Do 246 20 1 (5 + [size of "line"])

									[code for "line"]		>

									

								


