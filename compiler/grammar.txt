/* XXX: (*p)++ doesn't parse, maybe it should */

/* types */
/* TODO: structs and whatever else */

basic-type := 'int'

/* ====================================================== */

/* declaration stuff */

/* e.g. int a, b, c; */
decl := basic-type decl2 { ',' decl2 }
	| struct-decl

/*
 * 	*foo
 *	**foo = 123
 *	foo[12]
 *	*foo[12]
 */	
decl2 := { '*' } ident [ ('=' expr) | { ('[' integer ']') } ]

/*
 * struct foo {
 *	int field_a;
 * 	char herp_derp[128];
 *	char *pointer_to_whatever;
 * }
 */
struct-decl := 'struct' ident '{'
	decl ';'
	{ decl ';' }
'}'

/* TODO stuff like "struct derp* foo;" */

/* ====================================================== */

/* casts */
/* TODO: non-basic types ... */

/*
 *	(int *) p
 *	(CAST (CAST_TYPE (BASE_TYPE (INT_DECL)) (DECL_STAR)) (VARIABLE:p)) 
 */

cast := '(' cast-type ')' unary_expr
cast-type := basic-type {'*'}
		| struct-decl
		| <typedef-tag>

/* ====================================================== */

block := expr ';' 
	| decl ';'
	| if '(' expr ')' block [else block] 
	| while '(' expr ')' block 
	| for '(' [expr] ';' [expr] ';' [expr] ')' block
	| '{' { expr ';' } '}' 
	| instr '(' expr1, expr2, ..., exprN ')' ';'
	| ident ':'
	| goto ident ';'
	| [cast-type] ident '(' arg { ',' arg } ')' block
	| 'return' expr ';'
	| 'break' ';'
	| 'typedef' cast-type ident ';'

arg := [cast-type] ident

expr := lvalue asg-op expr 
	| ccor_expr
	| str-const

/*
 * Notice [] binds tighter than *
 */
lvalue := ident { '[' expr ']' }  | '*' unary-expr
	  | '(' cast-type ') lvalue
	  | '(' lvalue ')'

ccor_expr := ccand_expr ['||' ccand_expr]

ccand_expr := comp_expr ['&&' comp_expr]

comp_expr := sum_expr [comp-op sum_expr]

sum_expr := mul_expr { add-op mul_expr }

mul_expr := dot_expr { mul-op dot_expr }

/* XXX: If the `.' (struct tag access) operator isn't left-associative,
 * this will have to be changed */
dot_expr := unary_expr {'.' unary_expr }

unary_expr := ([ - ] ( lvalue | integer
			      | char-const 
		  	      | unary_expr
		 	      | octal-integer
		  	      | hex-integer ) ) 
		|  '(' expr ')' 
		| lvalue ++ 
		| lvalue --
		| ++ lvalue 
		| -- lvalue
		| ident '(' expr1, expr2, exprN ')'
		| '&' lvalue
		| '!' unary_expr
		| cast
