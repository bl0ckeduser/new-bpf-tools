/* declaration stuff */

basic-type := 'int'

/* e.g. int a, b, c; */
decl := basic-type decl2 { ',' decl2 }

/*
 * 	*foo
 *	**foo = 123
 *	foo[12]
 *	*foo[12]
 */	
decl2 := { '*' } ident [ ('=' expr) | { ('[' integer ']') } ]


/* ====================================================== */

block := expr ';' 
	| decl ';'
	| if '(' expr ')' block [else block] 
	| while '(' expr ')' block 
	| for '(' [expr] ';' [expr] ';' [expr] ')' block
	| '{' { expr ';' } '}' 
	| instr '(' expr1, expr2, ..., exprN ')' ';'
	| ident ':'
	| goto ident ';'
	| ['proc'] ident '(' ident { ',' ident } ')' block
	| 'return' expr ';'

expr := lvalue asg-op expr 
	| ccor_expr
	| str-const

/*
 * Notice [] binds tighter than *
 */
lvalue := ident { '[' expr ']' }  | '*' lvalue

ccor_expr := ccand_expr ['||' ccand_expr]

ccand_expr := comp_expr ['&&' comp_expr]

comp_expr := sum_expr [comp-op sum_expr]

sum_expr := mul_expr { add-op mul_expr }

mul_expr := unary_expr { mul-op unary_expr }

unary_expr := ([ - ] ( lvalue | integer
			      | char-const 
		  	      | unary_expr
		 	      | octal-integer
		  	      | hex-integer ) ) 
		|  '(' expr ')' 
		| lvalue ++ 
		| lvalue --
		| ++ lvalue 
		| -- lvalue
		| ident '(' expr1, expr2, exprN ')'
		| '&' lvalue
		| '!' unary_expr
