/* 
 * NOTE: the file "11_precedence.c" from the TCC
 * test suite (http://bellard.org/tcc/)
 * tests precedence.  useful !
 */

/* types */
/* TODO: structs and whatever else */

basic-type := 'int'

/* ====================================================== */

/* declaration stuff */

/* e.g. int a, b, c; */
decl := (basic-type | struct-decl) decl2 { ','  decl2 } 
	| struct-decl

/*
 * 	*foo
 *	**foo = 123
 *	foo[12]
 *	*foo[12]
 */	
decl2 := { '*' } ident [ { ('[' [integer] ']') } ] ['=' initializer]

/* must use expr0 here to avoid conflict with ',' in expr */
initializer := expr0
		| '{' {'{'} expr0 {'}'} [ {',' {'{'} expr0 {'}'}}] '}'

/*
 * struct foo {
 *	int field_a;
 * 	char herp_derp[128];
 *	char *pointer_to_whatever;
 * }
 */
struct-decl := 'struct' [ident] '{' decl ';' { decl ';' } '}'
		| 'struct' [ident] decl2 { ','  decl2 } ';'

/* TODO stuff like "struct derp* foo;" */

/* ====================================================== */

/* casts */
/* TODO: non-basic types ... */

/*
 *	(int *) p
 *	(CAST (CAST_TYPE (BASE_TYPE (INT_DECL)) (DECL_STAR)) (VARIABLE:p)) 
 */

cast := '(' cast-type ')' e0
cast-type := basic-type {'*'}
		| struct-decl
		| <typedef-tag> {'*'}
		| 'struct' ident {'*'}

/* ====================================================== */

block := expr ';' 
	| decl ';'
	| if '(' expr ')' block [else block] 
	| while '(' expr ')' block 
	| for '(' [expr] ';' [expr] ';' [expr] ')' block
	| '{' { expr ';' } '}' 
	| instr '(' expr1, expr2, ..., exprN ')' ';'
	| ident ':'
	| goto ident ';'
	| [cast-type] ident '(' arg { ',' arg } ')' block
	| 'return' [expr] ';'
	| 'break' ';'
	| 'typedef' cast-type ident ';'

arg := [cast-type] ident

expr := expr0 [, expr0]

expr0 := e1 asg-op expr 
	| ternary-expr
	| str-const

lvalue := ident
          | '(' cast-type ') lvalue
	  | '(' lvalue ')'

ternary-expr := ccor_expr
		| ccor_expr '?' expr ':' expr

ccor_expr := ccand_expr ['||' ccand_expr]

ccand_expr := bor_expr ['&&' bor_expr]

/* token: TOK_PIPE, node : BOR */
bor_expr := bxor_expr ['|' bxor_expr]

/* token: TOK_CARET, node: BXOR */
bxor_expr := band_expr ['^' band_expr]

/* token: TOK_ADDR, node: BAND */
band_expr = comp_expr ['&' comp_expr]

comp_expr := sum_expr [comp-op sum_expr]

sum_expr := mul_expr { add-op mul_expr }

mul_expr := e1 { mul-op e1 }

/* 
 * I have tried to follow this table:
 * http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm
 */

e1 := '++' e1
	 | '--' e1
	 | '-' e1
	 | '!' e1
	 | cast
	 | '*' e1
	 | '&' e1
	 | e0

e0 :=
	| e0_2 '++'
	| e0_2 '--'
	| e0_2

e0_2 := e0_3 { '[' expr ']' }

/* 
 * . and -> have to be left-associative !!!!! otherwise
 * funny things happen: for example the expression
 * a->b->c is parsed as a->(b->c) and the compiler
 * segfaults trying to look up the tag in "a" specified
 * by the tree for "b->c".
 */
e0_3 :=
	 e0_4 {'.' e0_4}
	| e0_4 {'->' e0_4}
	| e0_4

e0_4 := 'sizeof' cast-type
	'sizeof' expr
	ident '(' expr1, expr2, exprN ')'
	| '(' expr ')'
	| lvalue
	| integer
	| octal-integer
	| hex-integer
	| char-const
