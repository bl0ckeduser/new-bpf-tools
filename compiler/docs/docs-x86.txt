		=============================================
  		Some documentation on the 32-bit x86 compiler
		=============================================

			     ---------
			      Scripts
			     ---------

The (unix shell) scripts to use the x86-targeting compiler are:

	build-x86.sh 		-- build the x86 compiler
	autotest-x86.sh 	-- test the x86 compiler against test/*.c
	compile-run-x86.sh 	-- compile and run a program via x86

Quick example:
	$ ./build-x86.sh 
	$ ./compile-run-x86.sh test/procedure 
	120

The 32-bit x86 code generator outputs GAS assembly and the test scripts
assemble this using gcc. clang also works; you can modify the scripts to
use clang if desired.

			   ------------
			      Syntax
			   ------------
			
Below is a quick overview of the language syntax. < > symbols denote
an optional part in a construction. If the choice of some paragraphs
seems strange, remember that I'm trying to follow the grammar's 
structure closely.

1. Code blocks
	i. empty block
		;
	ii. single-instruction block
		e.g. x += 1;
	iii. multi-instruction blocks
		e.g.
		{
			x += 1;
			y = x + 2;
			if (x > 2)
				++y;
		}

2. Variable declarations
	i. integers
		int variable_name < = expression >;
	ii. arrays
		int array_name[integer];
	iii. pointers
		int *ptr;
	iv. characters
		char c;

	You can also do combinations like char ****ptr,
	int *ptr[32], etc., but that hasn't been very well tested
	yet. In any event, test/x86/*.c gives an idea of the C subset
	supported at any given point in the "development" of this project.

3. Control flow
	i. if statement
		if (expr)
			block1
		< else
			block2 >
	ii. while statement
		while (expr)
			block

	iii. for statement
		for (<init>; <condition>; <increment>)
			block
	
	     init, condition, increment are expressions.
	     if condition is ommitted, the compiler writes in
	     "1 == 1" (always true) instead.

	     In general, the statement will be rewritten as:

		init;
		while (condition) {
			block;
			increment;
		}

4. Arithmetic
	Operands are any kind of expression: number, variable, array
	index, etc.
	e.g. 
		1 + 2 * 3 		(evaluates to 7)
		(1 + 2) * 3		(evaluates to 9)
		456 % 123		(evaluates to 87)
		z - x * x + 123		(evaluates to something)	
		-x + 5

	The type of the result depends... If you add one or more
	integers to a pointer, the result is a pointer. If you
	subtract two pointers, the result is an integer. If you
	try to multiply, subtract more than two, divide, or remainder 
	pointers, the result is an unhappy compiler that tells you
	it won't compile nonsense.
		
5. Assignment operators
	Left operand is an lvalue, right operand is an expression.
	e.g.
		x += 3;
		foo += foo * bar;
		variable = 123;
		array[12] = 34;
		z -= 56;

	The type is the type of the left operand, i.e. the "lvalue".

6. lvalues (essentially, objects to which you can assign values)
	e.g.
		table[index]
		variable

7. C-style increments and decrements
	The operand is any lvalue. The type is the type of the operand.
	e.g.
		++foo;		tab[bobobo]--;
		--bar;		mystery++;

8. "Special" instructions
	echo(n); writes out an integer and a newline to stdout.
	Might as well use printf("%d\n", n); instead -- that's
	exactly how echo(n) is programmed but it'll work on real
	C compiler unlike this echo nonsense.

9. Relational operators
		exprA == exprB
		exprA != exprB
		exprA >= exprB
		exprA <= exprB
		exprA > exprB
		exprA < exprB

   These work as in C, and follow C's convention of "nonzero true, 
   zero false". The type of a comparison is always "int", regardless
   of the type of its operands (the compiler will do its best to
   convert the operands to int before comparing them, and then it'll
   give you an int result).

10. Comments
	/* this is a C-style comment */
	// this is a C++ -style comment.
	// (C++ -style comments last till the end of the line)

11. Calling libc routines

	It is possible to call libc routines like printf(),
	getchar(), etc, just as you would in C.
	
	For example:
		printf("herp derp hello world\n");
		int c = getchar();
		int buf[128];
		scanf("%s", buf);
	etc.

12. Custom procedures

	See examples: test/x86/lexical.c, test/x86/procedure.c,
	test/x86/square.c, test/x86/tco.c.

	Recursion is allowed. Tail-call optimization is done when it
	can be done. You are allowed to return nothing from a 
	function; if anything tries to use the result it will get
	random garbage.

13. Pointers

	The & (address-of) and * (dereference) operators from C
	have been implemented.

	* can be applied to any expression
	& can be applied to lvalues only

	Arrays symbols are implicitly converted to pointers to 
	the first element of the array.

	For example:
		int array[32];
		int ptr = array;
		*array = 123;
		printf("%d\n", array[0]);	// 123

14. String constants

	Examples:

	"bob 123"
	printf("hello\n");

15. Logical operations

		&&, ||, and ! have been copied from C.
	
	Like for the relational operators (==, !=, et al.), the
	result is of type "int", and the compiler will do its
	best to convert the arguments to "int" before applying
	the operation.

16. Pointer arithmetic

	There is basic support for pointer arithmetic, another
	strange feature from C. See "test/x86/ptr-arith.c"
	and "test/x86/incdec.c" for example code.

	For example, if you do this:
		int *ptr;
		
	and then you use the expression:
		ptr + 4

	The compiler will play a funny old joke on you whereby
	"ptr + 4" isn't literally "ptr + 4" but rather
	"ptr + 4 * sizeof(int)" in a strict arithmetic sense.

	This way you can write *(ptr + 4) to mean ptr[4].
	Actually I think the real original UNIX C compiler internally
	rewrote ptr[4] to *(ptr + 4), so there you go.

17. Casts

	Casts are a work-in-progress.

	The type analyzer (coded in "typeof.c") takes notice of them.

	At this point, the main use for them is for casted
	pointer dereferences, e.g. *(char *)ptr
	-- see test/x86/array-asst.c for an example of these.

18. Type system

	C's "char", "int", and 1-d arrays and/or n-depth pointers
	of these can be declared and used, but as of writing some
	operations only compile accurately for "int" and "int *", and
	some operations may not compile at all. In any event, the
	test/x86/*.c files give an idea of the subset of C that is
	supported at any given point.

	As soon as something is a pointer, whatever it happens to
	point to, it has word- (i.e. 32-bit)- size.

.............................................................................

			-------------------------
			Operator precedence table
			-------------------------

From greatest to lowest precedence:

	[] (array subscript)
	* (dereference)
	- (unary), ( ), ++, --, procedure calls, & (address-of), !
	(...)  (cast)
	* (multiplication) / %
	+ -
	> >= < <= == !=
	&&
	||
	= += -= *= /=

All arithmetic operators are left-associative.

Assignment is right-associative.

Comparison operators are not associative: expressions like 1 < 2 < 3
will raise syntax errors. -- actually that needs to be fixed, the parser
left-associates them as of writing because of a too-quick refactor storm.

.............................................................................
