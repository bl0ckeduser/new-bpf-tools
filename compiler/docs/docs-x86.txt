		=============================================
  		Some documentation on the 32-bit x86 compiler
		=============================================

			     ---------
			      Scripts
			     ---------

The (unix shell) scripts to use the x86-targeting compiler are:

	build-x86.sh 		-- build the x86 compiler
	autotest-x86.sh 	-- test the x86 compiler against test/*.c
	compile-run-x86.sh 	-- compile and run a program via x86

Quick example:
	$ ./build-x86.sh 
	$ ./compile-run-x86.sh test/x86/square.c 
	625
	$ 

The 32-bit x86 code generator outputs GAS assembly and the test scripts
assemble this using gcc. clang also works; you can modify the scripts to
use clang if desired.

			   ------------
			      Syntax
			   ------------
			
Below is a quick overview of the language syntax. < > symbols denote
an optional part in a construction. If the choice of some paragraphs
seems strange, remember that I'm trying to follow the grammar's 
structure closely.

1. Code blocks
	i. empty block
		;

	ii. single-instruction block
		e.g. x += 1;

	iii. multi-instruction blocks
		e.g.
		{
			x += 1;
			y = x + 2;
			if (x > 2)
				++y;
		}

2. Variable declarations

	The supported base types are:	

		int
		char

	Here are some quick examples of declarations:

		int variable_name;
		int variable_name_2 = 29239;
		int a, *pa = &a, cd = 456;
		int array_name[1000];
		int matrix[10][10];
		int *ptr;
		int **ptr_ptr;
		char c;
		char *buf;
		char *strings[32];

	And now a formal description of what is parsed:

		Declarations start with either "int" or "char".
		Then there is a sequence of sub-declarations separated by 
		commas. Each sub-declaration first contains 0 or more pointer 
		stars, then it contains the name of the variable, then it 
		may optionally contain either an initialization assignment 
		or any number of array-dimension integers-in-brackets 
		(e.g. [123]). 2d, 3d, ... arrays are supported.

3. Control flow
	i. if statement
		if (expr)
			block1
		< else
			block2 >

	ii. while statement
		while (expr)
			block

	iii. for statement
		for (<init>; <condition>; <increment>)
			block
	
	     "init", "condition", and "increment" are expressions.
	     if "condition" is ommitted, the compiler writes in
	     "1 == 1" (an always-true expression) instead.

	     In general, the statement will be rewritten as:

		init;
		while (condition) {
			block;
			increment;
		}

	iv. break statement
		while (expr) {
			...
			break;
			...
		}

		A break statement exits a "while" or "for" loop, like in C.

4. Arithmetic
	Operands are any kind of expression: number, variable, array
	index, etc. Standard precedence and associativity (left) 
	are enforced. Parentheses can force altered precedence.

	Some examples:	
		1 + 2 * 3 		(evaluates to 7)
		(1 + 2) * 3		(evaluates to 9)
		456 % 123		(evaluates to 87)
		z - x * x + 123		(evaluates to something)	
		-x + 5			(evaluates to something)

	The type of the result depends on several factors: 
	if you add one or more integers to a pointer, the result 
	is a pointer. If you subtract two pointers, the result 
	is an integer. If you try to multiply, subtract more 
	than two, divide, or remainder pointers, the result 
	is an unhappy compiler that tells you it won't compile nonsense.
	If you just add a bunch of numbers, the result is int.
		
5. Assignment / compound-assignment operators
	The left operand must be an lvalue; the right operand 
	can be any expression.

	Examples:
		x += 3;
		foo += foo * bar;
		variable = 123;
		array[12] = 34;
		var -= 123;
		var += 123;
		var %= 123;
		var /= 123;
		var *= 123;

	The type is the type of the left operand, i.e. the "lvalue".

6. lvalues (essentially, objects to which you can assign values)
	e.g.
		table[index]
		variable
		*pointer
		**pointer_to_pointer

7. C-style increments and decrements
	The operand is any lvalue. The type is the type of the operand.
	e.g.
		++foo;		tab[bobobo]--;
		--bar;		mystery++;
		++*ptr;	

	"Pointer arithmetic" weirdness applies -- i.e. incrementing
	a pointer to data of a given size actually increases it by
	this given size, and similarly decrementing subtracts this
	given size. For example, if ptr is a pointer to int,
	++ptr actually increases ptr by 4, because on 32-bit x86
	an int is 4 bytes.

8. "Special" instructions
	echo(n); writes out an integer and a newline to stdout.
	Might as well use printf("%d\n", n); instead -- that's
	exactly how echo(n) is programmed but it'll work on real
	C compiler unlike this echo nonsense.

9. Relational operators
		exprA == exprB
		exprA != exprB
		exprA >= exprB
		exprA <= exprB
		exprA > exprB
		exprA < exprB

   These work as in C, and follow C's convention of "nonzero true, 
   zero false". The type of a comparison is always "int", regardless
   of the type of its operands (the compiler will do its best to
   convert the operands to int before comparing them, and then it'll
   give you an int result). Relational operators are not associative.

10. Comments
	/* this is a C-style comment */
	// this is a C++ -style comment.
	// (C++ -style comments last till the end of the line)

11. Calling libc routines

	It is possible to call libc routines like printf(),
	getchar(), puts(), etc, just as you would in C.

	(Well, at the moment, strictly speaking, only
	those routines which take "int" arguments and return "int")
	
	For example:
		printf("herp derp hello world\n");
		int c = getchar();
		int buf[128];
		scanf("%s", buf);
	etc.

12. Custom procedures

	See example code files: test/x86/lexical.c, test/x86/procedure.c,
	test/x86/square.c, test/x86/tco.c, test/x86/recursive-fib.c.

	Recursion is allowed. Tail-call optimization is done when it
	can be done within one same function. You are allowed to 
	never "return" anything from a function; if anything tries to use 
	the return value it will get random garbage.

13. Pointers

	The & (address-of) and * (dereference) operators from C
	have been implemented.

	* can be applied to any expression, but funny things
	will happen when you run the compiled code if the expression
	isn't actually a pointer.

	& can be applied to lvalues only.

	Arrays symbols are implicitly converted to pointers to 
	the first element of the array.

	For example:
		int array[32];
		int ptr = array;
		*array = 123;
		printf("%d\n", array[0]);	// 123

14. String constants

	Example: "bob 123"

	Example use: printf("hello\n");

15. Logical operations

	&&, ||, and ! have been copied from C. They "short-circuit"
	like in C, so for example

			0 && ++x;

	does not increase x.
	
	Like for the relational operators (==, !=, et al.), the
	result is of type "int".

16. Pointer arithmetic

	There is basic support for pointer arithmetic, another
	strange feature from C. See "test/x86/ptr-arith.c"
	and "test/x86/incdec.c" for example code.

	For example, if you do this:
		int *ptr;
		
	and then you use the expression:
		ptr + 4

	The compiler will play a funny old joke on you whereby
	"ptr + 4" isn't literally "ptr + 4" but rather
	"ptr + 4 * sizeof(int)" in a strict arithmetic sense.

	This way you can write *(ptr + 4) to mean ptr[4].
	Actually I think the real original UNIX C compiler internally
	rewrote ptr[4] to *(ptr + 4), so there you go.

17. Casts

	Examples:  *(char*)ptr;	 *(int*)ptr;	(int)var;

	The type analyzer (coded in "typeof.c") takes notice of them.

	At this point, the main use for them is for casted
	pointer dereferences, e.g. *(char *)ptr
	-- see test/x86/array-asst.c for an example of these.

18. Type system

	C's "char", "int", and 1-d arrays and/or n-depth pointers
	of these can be declared and used, but as of writing some
	operations only compile accurately for "int" and "int *", and
	some operations may not compile at all. In any event, the
	test/x86/*.c files give an idea of the subset of C that is
	supported at any given point.

	As soon as something is a pointer, whatever it happens to
	point to, it has word- (i.e. 32-bit)- size.

	casts are an important part of the type system.

			-------------------------
			   Operator precedence
			    and associativity
			-------------------------

From greatest to lowest precedence:

	[] (array subscript)
	* (dereference)
	- (sign), ( ), ++, --, procedure calls, & (address-of), !
	(...)  (cast)
	* (multiplication) / %
	+ -
	> >= < <= == !=
	&&
	||
	= += -= *= /=

All arithmetic operators (+ et al.) are left-associative.

The logical connectives (&& and ||) are left-associative.

Assignment (=) and compound-assignment operators (+= et al.) 
are right-associative.

Comparison operators are not associative: expressions like 1 < 2 < 3
will raise syntax errors.

.............................................................................
